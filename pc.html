<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Est√∫dio Criativo HD - Vers√£o Brush Pro</title>
    <style>
        :root {
            --primary: #8b5cf6;
            --accent: #38bdf8;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark: #0f172a;
            --panel: #1e293b;
            --text: #f8fafc;
            --border: #334155;
        }

        * { box-sizing: border-box; user-select: none; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--dark);
            color: var(--text);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            background: rgba(15, 23, 42, 0.95);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            z-index: 50;
        }
        .header-left { display: flex; align-items: center; gap: 15px; }
        .toggle-sidebar-btn {
            background: transparent; border: 1px solid var(--border); 
            color: var(--text); border-radius: 4px; cursor: pointer;
            padding: 5px 10px; font-size: 1.2rem; transition: 0.2s;
        }
        .toggle-sidebar-btn:hover { background: var(--border); }

        h1 { 
            font-size: 1.2rem; margin: 0; 
            background: linear-gradient(to right, #c084fc, #38bdf8); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
        }

        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            height: calc(100vh - 50px);
            width: 100%;
            transition: grid-template-columns 0.3s ease;
        }
        
        .app-container.sidebar-closed {
            grid-template-columns: 0px 1fr;
        }

        .sidebar {
            background: var(--panel);
            border-right: 1px solid var(--border);
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 280px; 
            transform: translateX(0);
            transition: transform 0.3s ease;
        }

        .app-container.sidebar-closed .sidebar {
            transform: translateX(-100%);
        }
        
        .panel-section h3 { margin: 0 0 10px 0; font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px; }

        .sidebar-shapes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .shape-option {
            background: #334155;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid transparent;
        }
        .shape-option:hover { background: #475569; }
        .shape-option input { margin: 0; accent-color: var(--accent); cursor: pointer; }

        .custom-shape-wrapper {
            background: rgba(56, 189, 248, 0.1); 
            border: 1px solid var(--accent);
            border-radius: 6px;
            display: flex;
            align-items: center;
            overflow: hidden;
            transition: 0.2s;
        }
        .custom-shape-wrapper:hover { background: rgba(56, 189, 248, 0.2); }
        .custom-shape-label { flex: 1; padding: 8px; font-size: 0.8rem; color: #bae6fd; display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .custom-shape-label input { accent-color: var(--accent); margin: 0; }
        .btn-delete-shape {
            background: transparent; border: none; border-left: 1px solid rgba(56, 189, 248, 0.3);
            color: var(--accent); cursor: pointer; padding: 0 8px; height: 100%;
            display: flex; align-items: center; justify-content: center; font-size: 1rem; transition: 0.2s;
        }
        .btn-delete-shape:hover { background: var(--accent); color: #000; }

        .workspace {
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 15px;
            background: #020617;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            min-height: 0;
            background: #000;
            border-radius: 12px;
            border: 1px dashed var(--border);
            transition: all 0.3s ease;
        }

        .canvas-area:fullscreen {
            border: none; border-radius: 0; width: 100vw; height: 100vh;
            background: #000; display: flex; align-items: center; justify-content: center;
        }

        #btnExitFS {
            position: fixed; top: 20px; right: 20px; width: 40px; height: 40px;
            border-radius: 50%; background: rgba(239, 68, 68, 0.9); color: white;
            border: 2px solid rgba(255,255,255,0.2); font-size: 1.2rem; font-weight: bold;
            cursor: pointer; z-index: 9999; opacity: 0; 
            transition: opacity 0.3s ease, transform 0.2s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
        }
        #btnExitFS:hover { opacity: 1; transform: scale(1.1); }
        .canvas-area:not(:fullscreen) #btnExitFS { display: none !important; }

        canvas {
            max-width: 100%; max-height: 100%; aspect-ratio: 16/9;
            object-fit: contain; box-shadow: 0 0 40px rgba(0,0,0,0.6);
        }

        .controls-bar {
            height: auto;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 20px;
            display: grid;
            grid-template-columns: 1fr auto auto 1fr 1fr auto auto;
            gap: 15px;
            align-items: center;
            flex-shrink: 0;
            margin-bottom: 60px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }

        .btn {
            width: 100%; padding: 10px; border: none; border-radius: 6px;
            font-weight: 600; cursor: pointer; transition: 0.2s; font-size: 0.85rem;
            display: flex; align-items: center; justify-content: center; gap: 8px; color: white;
        }
        .btn:hover { filter: brightness(1.15); transform: translateY(-1px); }
        .btn:disabled { filter: grayscale(1); opacity: 0.5; cursor: not-allowed; }
        
        .btn-search { background: linear-gradient(135deg, #0ea5e9, #6366f1); }
        .btn-random { background: #f59e0b; color: #fff; } 
        .btn-upload { background: #334155; }
        .btn-create { background: var(--accent); color:black; margin-top: 10px; } 
        .btn-action { background: #334155; height: 100%; font-size: 1.2rem; width: 45px; }
        .btn-dl { background: #10b981; }
        .btn-rec { background: #ef4444; color: white; }
        .btn-rec.recording { animation: pulse-red 1.5s infinite; background: #991b1b; }
        .btn-fs { background: #6366f1; }
        
        .btn-toggle { background: #334155; color: #cbd5e1; border: 1px solid var(--border); }
        .btn-toggle.active { background: var(--success); color: #000; border-color: var(--success); box-shadow: 0 0 10px rgba(34, 197, 94, 0.4); }
        
        .btn-trend { background: rgba(255,255,255,0.03); color: #cbd5e1; border: 1px solid var(--border); text-align: left; padding: 8px; font-size: 0.8rem; display: flex; justify-content: space-between; }
        .btn-trend:hover { border-color: var(--accent); background: rgba(255,255,255,0.08); }

        .control-group { display: flex; flex-direction: column; gap: 4px; transition: opacity 0.3s; }
        .control-group.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .control-label { font-size: 0.75rem; color: #94a3b8; display: flex; justify-content: space-between; }
        input[type=range] { width: 100%; accent-color: var(--primary); height: 4px; cursor: pointer; }
        select { background: #0f172a; border: 1px solid var(--border); color: white; padding: 4px; border-radius: 4px; width: 100%; font-size: 0.85rem;}

        .status-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.9); z-index: 10;
        }
        .status-text { background: #1e293b; padding: 15px 25px; border-radius: 8px; color: #f1f5f9; border: 1px solid var(--border); text-align: center; }
        .loader {
            width: 40px; height: 40px; border: 4px solid #FFF; border-bottom-color: var(--accent);
            border-radius: 50%; animation: rotation 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }

        #searchPanel { display: none; background: #0f172a; padding: 10px; border-radius: 6px; border: 1px solid var(--accent); margin-bottom: 5px; }
        #searchInput { width: 100%; background: transparent; border: 1px solid var(--border); color: white; padding: 8px; margin-bottom: 8px; font-size: 0.9rem;}

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            z-index: 1000; display: none; align-items: center; justify-content: center;
        }
        .modal-overlay.active { display: flex; }
        
        .creator-panel {
            background: var(--panel); border: 1px solid var(--border);
            padding: 20px; border-radius: 12px; 
            width: auto; max-width: 95vw;
            display: flex; flex-direction: column; gap: 15px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }
        
        .creator-canvas-wrapper {
            width: 400px; height: 400px; 
            background-color: #0f172a;
            background-image: linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            border: 2px solid var(--border); border-radius: 8px;
            cursor: crosshair; overflow: hidden;
            display: block; position: relative;
        }
        #creatorCanvas { display: block; width: 100%; height: 100%; }

        .creator-tools { display: flex; gap: 10px; }
        .tool-btn { flex: 1; padding: 8px; background: #334155; border: none; color: white; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 5px;}
        .tool-btn:hover { background: #475569; }
        .tool-btn-imp { background: var(--accent); color: black; font-weight: 500; }
        
        @media (max-width: 900px) {
            .app-container { grid-template-columns: 1fr; }
            .sidebar { position: fixed; left: 0; top: 50px; bottom: 0; z-index: 100; box-shadow: 5px 0 15px rgba(0,0,0,0.5); }
            .controls-bar { grid-template-columns: 1fr 1fr; gap: 10px; height: auto; margin-bottom: 20px;}
        }

    </style>
</head>
<body>

    <div class="modal-overlay" id="creatorModal">
        <div class="creator-panel">
            <h2 style="margin:0; font-size: 1.2rem; color:white;">Criar Nova Forma</h2>
            <div style="font-size: 0.8rem; color: #94a3b8;">
                Desenhe ou importe um PNG. O sistema ir√° "escanear" a forma automaticamente.
            </div>
            
            <div class="creator-tools">
                <button class="tool-btn" id="btnClearShape">üóëÔ∏è Limpar</button>
                <label class="tool-btn tool-btn-imp">
                    üìÇ Importar PNG
                    <input type="file" id="importShapeInput" hidden accept="image/*">
                </label>
            </div>

            <div class="creator-canvas-wrapper">
                <canvas id="creatorCanvas" width="400" height="400"></canvas>
            </div>
            
            <input type="text" id="shapeNameInput" placeholder="Nome da forma (ex: Estrela)" style="padding: 10px; background: #0f172a; border: 1px solid var(--border); color: white; border-radius: 4px;">

<label style="display: flex; align-items: center; gap: 8px; font-size: 0.9rem; color: #cbd5e1; cursor: pointer; background: #334155; padding: 8px; border-radius: 4px;">
    <input type="checkbox" id="fixedDirectionCheck" style="accent-color: #a855f7; width: 16px; height: 16px;">
    üîí Dire√ß√£o √önica (N√£o rotacionar)
</label>

<div class="creator-tools">
            
            <div class="creator-tools">
                <button class="tool-btn" onclick="toggleCreator(false)" style="background: transparent; border: 1px solid var(--border);">Cancelar</button>
                <button class="tool-btn" id="btnSaveShape" style="background: var(--success); color:black; font-weight:bold;">Salvar Forma</button>
            </div>
        </div>
    </div>

    <header class="header">
        <div class="header-left">
            <button class="toggle-sidebar-btn" id="sidebarToggle" title="Minimizar/Expandir Menu">‚ò∞</button>
            <div>
                <h1>Gerador de Arte Geom√©trica</h1>
                <div style="font-size: 0.8rem; color: #64748b;"></div>
            </div>
        </div>
    </header>

    <div class="app-container" id="appGrid">
        <aside class="sidebar">
            <div class="panel-section">
                <h3>Fontes de Imagem</h3>
                <button id="btnRandom" class="btn btn-random" style="margin-bottom: 8px;">üé≤ Aleat√≥ria</button>
                <button id="btnToggleSearch" class="btn btn-search" style="margin-bottom: 8px;">üîç Pesquisar Tema</button>
                <div id="searchPanel">
                    <input type="text" id="searchInput" placeholder="Ex: Gato, Praia, Neon...">
                    <button id="btnDoSearch" class="btn" style="background:var(--accent); color:#000; padding: 5px;">Buscar Foto</button>
                </div>
                <label class="btn btn-upload">
                    üìÇ Upload Arquivo
                    <input type="file" id="fileInput" hidden accept="image/*">
                </label>
            </div>

            <hr style="border:0; border-top:1px solid var(--border); width: 100%;">
            
            <div class="panel-section">
                <h3>Efeitos Avan√ßados</h3>
                <label class="shape-option" style="margin-bottom: 8px;">
                    <input type="checkbox" id="flowFieldCheck"> 
                    <span>üåä Flow Field (Seguir bordas)</span>
                </label>
                
                <div class="control-label" style="margin-top: 5px;">üé® Paleta de Cores</div>
                <select id="colorPaletteSelect" style="margin-bottom: 10px;">
                    <option value="original">Original (Foto)</option>
                    <option value="cyberpunk">Cyberpunk (Roxo/Neon)</option>
                    <option value="noir">Noir (Preto e Branco)</option>
                    <option value="fire">Inferno (Laranja/Preto)</option>
                    <option value="matrix">Matrix (Verde/Preto)</option>
                </select>
            </div>

            <hr style="border:0; border-top:1px solid var(--border); width: 100%;">
            
            <div class="panel-section">
                <h3>Formas Geom√©tricas</h3>
                <div class="sidebar-shapes" id="shapesContainer">
                    <label class="shape-option"><input type="checkbox" value="circle" checked> Bolas</label>
                    <label class="shape-option"><input type="checkbox" value="square" checked> Cubos</label>
                    <label class="shape-option"><input type="checkbox" value="triangle"> Tri√¢ng</label>
                    <label class="shape-option"><input type="checkbox" value="line"> Linhas</label>
                </div>
                <button id="btnOpenCreator" class="btn btn-create">‚ûïCrie Formas</button>
            </div>
            
            <hr style="border:0; border-top:1px solid var(--border); width: 100%;">
            
            <div class="panel-section" style="flex: 1;">
                <h3>üî• Top Buscas</h3>
                <div id="trendingList" style="display: flex; flex-direction: column; gap: 6px;"></div>
            </div>
        </aside>

        <main class="workspace">
            <div class="canvas-area" id="canvasContainer">
                <button id="btnExitFS" title="Sair da Tela Cheia">‚úï</button>

                <div class="status-overlay" id="statusOverlay">
                    <span class="loader" id="loader"></span>
                    <div class="status-text" id="statusText">Escolha uma op√ß√£o √† esquerda para come√ßar</div>
                </div>
                <canvas id="artCanvas"></canvas>
            </div>

            <div class="controls-bar">
                <div class="control-group">
                    <div class="control-label">‚è±Ô∏è Trocar em</div>
                    <select id="timeSelect">
                        <option value="15000">15 Segundos</option>
                        <option value="30000" selected>30 Segundos</option>
                        <option value="60000">1 Minuto</option>
                        <option value="120000">2 Minutos</option>
                        <option value="240000">4 Minutos</option>
                        <option value="9999999">Infinito</option>
                    </select>
                </div>

                <button id="btnDetailMode" class="btn btn-toggle active" title="Controla o tamanho automaticamente">
                    ‚ú® Evolu√ß√£o
                </button>

                <button id="btnFluidMode" class="btn btn-toggle active" title="N√£o limpa a tela ao trocar">
                    üåä Transi√ß√£o
                </button>

                <div class="control-group">
                    <div class="control-label">
                        <span>üöÄ Velocidade</span>
                        <span id="speedVal">Auto</span>
                    </div>
                    <input type="range" id="speedSlider" min="1" max="50" value="40">
                </div>

                <div class="control-group disabled" id="abstractionGroup">
                    <div class="control-label">üìè Escala</div>
                    <input type="range" id="abstractionSlider" min="1" max="100" value="50">
                </div>
                
                <button id="btnRecord" class="btn btn-action btn-rec" title="Gravar V√≠deo (WebM)">üî¥</button>
                <button id="btnDownload" class="btn btn-action btn-dl" title="Salvar PNG">üíæ</button>
                <button id="btnFullscreen" class="btn btn-action btn-fs" title="Tela Cheia">‚õ∂</button>
            </div>
        </main>
    </div>

    <script>
        const config = { 
            width: 1920, height: 1080, 
            shapes: ['circle', 'square'], 
            abstraction: 50, paintSpeed: 40, duration: 30000, 
            isRunning: false, startTime: 0, 
            currentMode: 'none', currentTag: '', 
            evolutionMode: true, fluidMode: true,
            isLoadingNext: false,
            retryCount: 0, maxRetries: 10,
            useFlowField: false,
            colorPalette: 'original',
            flowAngles: null 
        };
        
        const customShapesRegistry = {}; 
        
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;

        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        let sourceData = null; 
        let sourceW = 0, sourceH = 0; 
        let animationFrameId = null, originalImg = null;

        function init() { canvas.width = config.width; canvas.height = config.height; generateTrending(); updateDetailBtnUI(); updateFluidBtnUI(); }

        function generateTrending() {
            const themes = [ { name: "Cyberpunk", tag: "cyberpunk,city", color: "#22d3ee" }, { name: "Natureza", tag: "forest,jungle", color: "#4ade80" }, { name: "Retrowave", tag: "synthwave,neon", color: "#f472b6" }, { name: "Espa√ßo", tag: "nebula,stars", color: "#818cf8" }, { name: "Geometria", tag: "geometric,architecture", color: "#fb923c" } ];
            const container = document.getElementById('trendingList'); container.innerHTML = '';
            themes.forEach((item, i) => {
                const btn = document.createElement('button'); btn.className = 'btn btn-trend';
                btn.innerHTML = `<span>#${i+1} ${item.name}</span> <span style="color:${item.color};">TOCAR</span>`;
                btn.onclick = () => { config.currentMode = 'search'; config.currentTag = item.tag; searchImage(item.tag); };
                container.appendChild(btn);
            });
        }

        function getSearchURL(keyword) {
            return `https://loremflickr.com/1920/1080/${encodeURIComponent(keyword)}?lock=${Date.now()}`;
        }

        function searchImage(keyword) { 
            config.currentMode = 'search'; config.currentTag = keyword;
            config.retryCount = 0;
            const url = getSearchURL(keyword);
            if(config.isRunning && config.fluidMode) loadSilentImage(url);
            else loadImage(url); 
        }

        function setLoading(isLoading, text) {
            const el = document.getElementById('statusOverlay');
            if(isLoading) { el.style.display = 'flex'; document.getElementById('statusText').innerText = text; document.getElementById('loader').style.display = 'block'; } else { el.style.display = 'none'; }
        }

        function loadImage(baseUrl) {
            setLoading(true, config.retryCount > 0 ? `Tentativa ${config.retryCount}/${config.maxRetries}...` : "Carregando imagem...");
            config.isRunning = false; 
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            const img = new Image(); img.crossOrigin = "Anonymous"; 
            img.onload = () => { originalImg = img; startArt(true); config.retryCount = 0; setLoading(false); };
            img.onerror = () => { handleImageError(true); };
            img.src = baseUrl;
        }

        function loadSilentImage(baseUrl) {
            if(config.isLoadingNext && config.retryCount === 0) return;
            config.isLoadingNext = true;
            const img = new Image(); img.crossOrigin = "Anonymous";
            img.onload = () => { originalImg = img; startArt(false); config.retryCount = 0; config.isLoadingNext = false; };
            img.onerror = () => { handleImageError(false); };
            img.src = baseUrl;
        }

        function handleImageError(isExplicit) {
            config.retryCount++;
            if (config.retryCount <= config.maxRetries) {
                const nextUrl = getSearchURL(config.currentTag);
                setTimeout(() => { isExplicit ? loadImage(nextUrl) : loadSilentImage(nextUrl); }, 1000);
            } else {
                config.retryCount = 0; config.currentMode = 'random';
                if(isExplicit) {
                    setLoading(true, "Erro. Voltando para Aleat√≥rio...");
                    setTimeout(() => { loadImage(`https://picsum.photos/1920/1080?random=${Date.now()}`); }, 2000);
                } else {
                    loadSilentImage(`https://picsum.photos/1920/1080?random=${Date.now()}`);
                }
            }
        }

        function triggerNextImage() { 
            config.retryCount = 0;
            if (config.currentMode === 'search') loadSilentImage(getSearchURL(config.currentTag));
            else if (config.currentMode === 'random') loadSilentImage(`https://picsum.photos/1920/1080?random=${Date.now()}`);
        }

        function startArt(clearCanvas) {
            const analysisW = config.width; 
            const analysisH = config.height;
            sourceW = analysisW; sourceH = analysisH;

            const offCanvas = document.createElement('canvas'); 
            offCanvas.width = analysisW; offCanvas.height = analysisH;
            const offCtx = offCanvas.getContext('2d'); 
            
            drawImageCover(offCtx, originalImg, analysisW, analysisH);
            
            try { 
                const imgData = offCtx.getImageData(0, 0, analysisW, analysisH);
                sourceData = imgData.data; 
                
                config.flowAngles = new Float32Array(analysisW * analysisH);
                for(let y = 1; y < analysisH - 1; y++) {
                    for(let x = 1; x < analysisW - 1; x++) {
                        const i = (y * analysisW + x) * 4;
                        const getLum = (ox, oy) => {
                            const idx = ((y+oy) * analysisW + (x+ox)) * 4;
                            return (sourceData[idx]*0.299 + sourceData[idx+1]*0.587 + sourceData[idx+2]*0.114);
                        };
                        
                        const gx = (getLum(1,-1) + 2*getLum(1,0) + getLum(1,1)) - (getLum(-1,-1) + 2*getLum(-1,0) + getLum(-1,1));
                        const gy = (getLum(-1,1) + 2*getLum(0,1) + getLum(1,1)) - (getLum(-1,-1) + 2*getLum(0,-1) + getLum(1,-1));
                        
                        config.flowAngles[y * analysisW + x] = Math.atan2(gy, gx) + Math.PI/2;
                    }
                }

            } catch(e) { 
                console.error(e);
                if(clearCanvas) handleImageError(true); else handleImageError(false); return;
            }

            if(clearCanvas || !config.fluidMode) { 
                if (config.colorPalette === 'cyberpunk') ctx.fillStyle = "#050014";
                else if (config.colorPalette === 'noir') ctx.fillStyle = "#000000";
                else if (config.colorPalette === 'fire') ctx.fillStyle = "#1a0500";
                else if (config.colorPalette === 'matrix') ctx.fillStyle = "#001a00";
                else ctx.fillStyle = "#111111"; 
                
                ctx.fillRect(0, 0, config.width, config.height); 
            }
            
            config.startTime = Date.now();
            config.isRunning = true; 
            if(!animationFrameId) loop();
        }

        function getOptimalSpeed(size) {
            const loops = (config.paintSpeed / 10) * Math.pow(160 / Math.max(size, 1), 1.25);
            return Math.floor(Math.max(loops, 3)); 
        }

        function getPaletteColor(r, g, b) {
            if (config.colorPalette === 'original') return `rgb(${r},${g},${b})`;
            
            const lum = (r * 0.299 + g * 0.587 + b * 0.114) / 255; 
            
            if (config.colorPalette === 'cyberpunk') {
                const rN = Math.floor(40 + (lum * (34 - 40)) + (lum * 200)); 
                const rf = 46 * (1-lum) + 0 * lum;
                const gf = 0 * (1-lum) + 242 * lum;
                const bf = 79 * (1-lum) + 255 * lum;
                return `rgb(${rf|0},${gf|0},${bf|0})`;
            }
            if (config.colorPalette === 'noir') {
                const val = lum * 255;
                return `rgb(${val|0},${val|0},${val|0})`;
            }
            if (config.colorPalette === 'fire') {
                 let rf, gf, bf;
                 if(lum < 0.5) {
                    const t = lum * 2;
                    rf = 255 * t; gf = 0; bf = 0;
                 } else {
                    const t = (lum - 0.5) * 2;
                    rf = 255; gf = 255 * t; bf = 0;
                 }
                 return `rgb(${rf|0},${gf|0},${bf|0})`;
            }
            if (config.colorPalette === 'matrix') {
                return `rgb(0, ${Math.floor(lum * 255)}, 0)`;
            }
            return `rgb(${r},${g},${b})`;
        }

        function loop() {
            if(!config.isRunning || !sourceData) { animationFrameId = null; return; }

            const elapsed = Date.now() - config.startTime;
            const duration = parseInt(config.duration);
            
            if(elapsed > duration) {
                if(!config.isLoadingNext && config.currentMode !== 'upload') triggerNextImage();
            }

            let currentBaseSize = 20;
            const T_GROW = 3000; const T_HOLD = 500; const T_TOTAL_TRANS = T_GROW + T_HOLD;

            if (config.evolutionMode) {
                if (config.fluidMode && elapsed < T_TOTAL_TRANS) {
                    if (elapsed < T_GROW) {
                        const t = elapsed / T_GROW;
                        currentBaseSize = 5 + (175 * (t*t)); 
                    } else { currentBaseSize = 180; }
                } else {
                    const progress = Math.min(elapsed / duration, 1.0);
                    const shrinkLimit = duration >= 120000 ? 0.4 : 0.6;
                    let sizeProgress = progress / shrinkLimit; 
                    if (sizeProgress > 1) sizeProgress = 1;
                    currentBaseSize = 40 * (4.0 * (1 - sizeProgress) + 0.1 * sizeProgress);
                }
            } else {
                currentBaseSize = map(config.abstraction, 1, 100, 5, 80);
            }
            if (currentBaseSize < 2) currentBaseSize = 2;

            let loopsThisFrame = getOptimalSpeed(currentBaseSize);
            if (loopsThisFrame > 600) loopsThisFrame = 600;

            let shapesToUse = config.shapes.length > 0 ? config.shapes : ['circle'];
            
            for(let i=0; i < loopsThisFrame; i++) {
                const ax = Math.floor(Math.random() * sourceW);
                const ay = Math.floor(Math.random() * sourceH);
                
                const idx = (ay * sourceW + ax) * 4;
                
                if (!sourceData[idx+3] || sourceData[idx+3] < 20) continue; 

                const x = (ax / sourceW) * config.width;
                const y = (ay / sourceH) * config.height;

                const naturalJitter = 0.6 + (Math.random() * 0.8);
                const brightness = (sourceData[idx] + sourceData[idx+1] + sourceData[idx+2]) / 3;
                const finalSize = currentBaseSize * (0.8 + (brightness / 255) * 0.4) * naturalJitter;
                
                const r = sourceData[idx], g = sourceData[idx+1], b = sourceData[idx+2];
                
                const colorStr = getPaletteColor(r,g,b);
                ctx.fillStyle = colorStr;
                ctx.strokeStyle = colorStr;

                let angle = 0;
                if (config.useFlowField) {
                    angle = config.flowAngles[ay * sourceW + ax];
                } else {
                    angle = Math.random() * Math.PI * 2;
                }
                
                drawShape(x, y, finalSize, shapesToUse[Math.floor(Math.random() * shapesToUse.length)], angle);
            }
            animationFrameId = requestAnimationFrame(loop);
        }

        function drawShape(x, y, size, s, angle) {
            if (customShapesRegistry[s]) {
                const points = customShapesRegistry[s];
                if (!points || points.length < 3) return; 
                
                // NOVO: Se a forma tiver a flag fixedRotation, for√ßamos o √¢ngulo para 0
                if (points.fixedRotation) {
                    angle = 0; 
                }

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle); 
                
                ctx.beginPath();
                ctx.moveTo(points[0].x * size, points[0].y * size);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x * size, points[i].y * size);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                return;
            }
            
            ctx.beginPath();
            if(s === 'circle') { 
                ctx.arc(x, y, size/2, 0, Math.PI*2); ctx.fill(); 
            }
            else if(s === 'square') { 
                ctx.save(); ctx.translate(x, y); ctx.rotate(angle); 
                ctx.rect(-size/2, -size/2, size, size); ctx.fill(); ctx.restore(); 
            }
            else if(s === 'triangle') { 
                ctx.save(); ctx.translate(x, y); ctx.rotate(angle + Math.PI/2); 
                const h = size * 0.866; 
                ctx.moveTo(0, -h/2); ctx.lineTo(-size/2, h/2); ctx.lineTo(size/2, h/2); 
                ctx.fill(); ctx.restore(); 
            }
            else if(s === 'line') { 
                ctx.lineWidth = Math.max(1, size/4); 
                ctx.moveTo(x-Math.cos(angle)*size, y-Math.sin(angle)*size); 
                ctx.lineTo(x+Math.cos(angle)*size, y+Math.sin(angle)*size); 
                ctx.stroke(); 
            }
        }

        function drawImageCover(ctx, img, w, h) {
            const r = Math.max(w / img.width, h / img.height);
            ctx.drawImage(img, (w - img.width * r) / 2, (h - img.height * r) / 2, img.width * r, img.height * r);
        }
        function map(v, a, b, c, d) { return c + ((v-a)/(b-a)) * (d-c); }

        document.getElementById('btnFullscreen').onclick = () => { const el = document.getElementById('canvasContainer'); el.requestFullscreen().catch(e=>alert(e)); };
        document.getElementById('btnExitFS').onclick = () => { if(document.exitFullscreen) document.exitFullscreen(); };
        
        document.getElementById('btnDetailMode').onclick = () => { config.evolutionMode = !config.evolutionMode; updateDetailBtnUI(); };
        document.getElementById('btnFluidMode').onclick = () => { config.fluidMode = !config.fluidMode; updateFluidBtnUI(); };

        function updateDetailBtnUI() { 
            const b = document.getElementById('btnDetailMode'), g = document.getElementById('abstractionGroup');
            if(config.evolutionMode) { b.classList.add('active'); g.classList.add('disabled'); document.getElementById('speedVal').innerText = "Auto"; }
            else { b.classList.remove('active'); g.classList.remove('disabled'); }
        }

        function updateFluidBtnUI() {
            const b = document.getElementById('btnFluidMode');
            if(config.fluidMode) { b.classList.add('active'); }
            else { b.classList.remove('active'); }
        }

        document.getElementById('timeSelect').onchange = (e) => config.duration = parseInt(e.target.value);
        document.getElementById('speedSlider').oninput = (e) => { config.paintSpeed = parseInt(e.target.value); if(!config.evolutionMode) document.getElementById('speedVal').innerText = config.paintSpeed > 30 ? "Turbo" : "Manual"; };
        document.getElementById('abstractionSlider').oninput = (e) => config.abstraction = parseInt(e.target.value);
        document.getElementById('flowFieldCheck').onchange = (e) => config.useFlowField = e.target.checked;
        document.getElementById('colorPaletteSelect').onchange = (e) => config.colorPalette = e.target.value;

        function updateShapesList() {
             config.shapes = Array.from(document.querySelectorAll('#shapesContainer input:checked')).map(c => c.value);
        }
        document.querySelectorAll('#shapesContainer input').forEach(cb => { cb.onchange = updateShapesList; });

        document.getElementById('btnDownload').onclick = () => { const a = document.createElement('a'); a.download = 'Arte_' + Date.now() + '.png'; a.href = canvas.toDataURL(); a.click(); };
        document.getElementById('btnRandom').onclick = () => { config.currentMode = 'random'; 
            if(config.isRunning && config.fluidMode) loadSilentImage(`https://picsum.photos/1920/1080?random=${Date.now()}`);
            else loadImage(`https://picsum.photos/1920/1080?random=${Date.now()}`); 
        };
        document.getElementById('btnToggleSearch').onclick = () => { const p = document.getElementById('searchPanel'); p.style.display = p.style.display === 'block' ? 'none' : 'block'; };
        document.getElementById('btnDoSearch').onclick = () => { const val = document.getElementById('searchInput').value; if(val) searchImage(val); };
        document.getElementById('searchInput').onkeypress = (e) => { if(e.key === 'Enter') { const val = document.getElementById('searchInput').value; if(val) searchImage(val); } };
        document.getElementById('fileInput').onchange = (e) => { const f = e.target.files[0]; if(f) { config.currentMode = 'upload'; setLoading(true, "Processando..."); const r = new FileReader(); r.onload = (evt) => loadImage(evt.target.result); r.readAsDataURL(f); } };

        document.getElementById('sidebarToggle').onclick = () => {
            document.getElementById('appGrid').classList.toggle('sidebar-closed');
        };

        document.getElementById('btnRecord').onclick = () => {
            if(isRecording) stopRecording();
            else startRecording();
        };

        function startRecording() {
            try {
                const stream = canvas.captureStream(30);
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                recordedChunks = [];
                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = saveRecording;
                mediaRecorder.start();
                isRecording = true;
                const btn = document.getElementById('btnRecord');
                btn.classList.add('recording');
                btn.innerHTML = '‚¨õ';
                btn.title = "Parar Grava√ß√£o";
            } catch(e) { alert("Grava√ß√£o n√£o suportada neste navegador."); }
        }

        function stopRecording() {
            if(!mediaRecorder) return;
            mediaRecorder.stop();
            isRecording = false;
            const btn = document.getElementById('btnRecord');
            btn.classList.remove('recording');
            btn.innerHTML = 'üî¥';
            btn.title = "Gravar V√≠deo";
        }

        function saveRecording() {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Video_Arte_${Date.now()}.webm`;
            a.click();
            URL.revokeObjectURL(url);
        }

        const creatorModal = document.getElementById('creatorModal');
        const creatorCanvas = document.getElementById('creatorCanvas');
        const cCtx = creatorCanvas.getContext('2d', { willReadFrequently: true });
        let isDrawing = false;
        let drawnPoints = []; 

        function toggleCreator(show) {
            creatorModal.classList.toggle('active', show);
            if(show) resetCreator();
        }

        function resetCreator() {
            cCtx.clearRect(0,0,400,400); 
            drawnPoints = [];
        }
        
        function getMousePos(evt) {
            const rect = creatorCanvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) * (creatorCanvas.width / rect.width),
                y: (evt.clientY - rect.top) * (creatorCanvas.height / rect.height)
            };
        }

        document.getElementById('btnClearShape').onclick = resetCreator;

        document.getElementById('importShapeInput').onchange = (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    radialScanImage(img);
                };
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        };

        // NOVA FUN√á√ÉO: Scanner Radial (muito mais robusto que o anterior)
        function radialScanImage(img) {
            resetCreator();
            const w = 150, h = 150; 
            const tempC = document.createElement('canvas');
            tempC.width = w; tempC.height = h;
            const tempCtx = tempC.getContext('2d');
            
            // Desenha imagem centralizada
            const scale = Math.min(w/img.width, h/img.height) * 0.85;
            const dw = img.width * scale, dh = img.height * scale;
            const dx = (w-dw)/2, dy = (h-dh)/2;
            tempCtx.drawImage(img, dx, dy, dw, dh);
            
            const data = tempCtx.getImageData(0, 0, w, h).data;
            const cx = w/2, cy = h/2;
            let points = [];
            
            // Dispara 72 raios (um a cada 5 graus)
            const rayCount = 72; 
            for (let i = 0; i < rayCount; i++) {
                const angle = (i / rayCount) * Math.PI * 2;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                // Vai do centro para fora
                let lastValidX = cx;
                let lastValidY = cy;
                
                // Escaneia do centro at√© a borda
                for (let r = 0; r < w/2; r++) {
                    const tx = Math.floor(cx + cos * r);
                    const ty = Math.floor(cy + sin * r);
                    
                    if (tx < 0 || tx >= w || ty < 0 || ty >= h) break;
                    
                    const idx = (ty * w + tx) * 4;
                    // Se o pixel n√£o √© transparente
                    if (data[idx+3] > 40) { 
                        lastValidX = tx;
                        lastValidY = ty;
                    }
                }
                
                // Normaliza para o canvas de 400px
                points.push({
                    x: lastValidX * (400/w),
                    y: lastValidY * (400/h)
                });
            }

            drawnPoints = points;
            redrawFromPoints();
        }

        function redrawFromPoints() {
            if(drawnPoints.length < 2) return;
            cCtx.clearRect(0,0,400,400);
            cCtx.beginPath();
            cCtx.moveTo(drawnPoints[0].x, drawnPoints[0].y);
            for(let i=1; i<drawnPoints.length; i++) cCtx.lineTo(drawnPoints[i].x, drawnPoints[i].y);
            cCtx.closePath();
            
            cCtx.strokeStyle = "#ef4444"; 
            cCtx.lineWidth = 3;
            cCtx.stroke();
            cCtx.fillStyle = "rgba(239, 68, 68, 0.2)";
            cCtx.fill();
        }

        creatorCanvas.addEventListener('mousedown', (e) => { 
            isDrawing = true; 
            drawnPoints = []; 
            const pt = getMousePos(e);
            drawnPoints.push(pt);
            cCtx.clearRect(0,0,400,400);
            cCtx.beginPath(); cCtx.moveTo(pt.x, pt.y);
        });

        creatorCanvas.addEventListener('mousemove', (e) => {
            if(!isDrawing) return;
            const pt = getMousePos(e);
            const last = drawnPoints[drawnPoints.length-1];
            if(Math.hypot(pt.x - last.x, pt.y - last.y) > 5) {
                drawnPoints.push(pt);
                cCtx.lineTo(pt.x, pt.y);
                cCtx.strokeStyle = "#38bdf8"; cCtx.lineWidth = 2; cCtx.stroke();
            }
        });

        creatorCanvas.addEventListener('mouseup', () => { 
            isDrawing = false; 
            if(drawnPoints.length > 2) {
                cCtx.lineTo(drawnPoints[0].x, drawnPoints[0].y);
                cCtx.strokeStyle = "#22c55e"; cCtx.stroke();
                cCtx.fillStyle = "rgba(34, 197, 94, 0.2)"; cCtx.fill();
            }
        });

        document.getElementById('btnSaveShape').onclick = () => {
            if(drawnPoints.length < 3) { alert("Desenhe ou importe uma forma!"); return; }

            const name = document.getElementById('shapeNameInput').value || 'Forma ' + (Object.keys(customShapesRegistry).length + 1);
            
            // NOVO: Ler o estado do checkbox
            const isFixed = document.getElementById('fixedDirectionCheck').checked;
            
            let minX=1000, maxX=0, minY=1000, maxY=0;
            drawnPoints.forEach(p => {
                if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x;
                if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y;
            });
            const width = maxX - minX;
            const height = maxY - minY;
            const centerX = minX + width/2;
            const centerY = minY + height/2;
            const scale = Math.max(width, height) || 1;

          const normalizedPoints = drawnPoints.map(p => ({
                x: (p.x - centerX) / scale,
                y: (p.y - centerY) / scale
            }));

            // NOVO: Salvar a propriedade de rota√ß√£o fixa dentro do array de pontos
            normalizedPoints.fixedRotation = isFixed;

            const id = 'custom_v_' + Date.now();
            customShapesRegistry[id] = normalizedPoints;

            const container = document.createElement('div');
            container.className = 'custom-shape-wrapper';
            
            // NOVO: Se for dire√ß√£o √∫nica, muda a borda para Roxo
            if (isFixed) {
                container.style.borderColor = '#a855f7'; // Roxo
                container.style.background = 'rgba(168, 85, 247, 0.1)';
            }
            
            const label = document.createElement('label');
            label.className = 'custom-shape-label';
            
            // NOVO: Se for dire√ß√£o √∫nica, muda o texto para Roxo
            if (isFixed) {
                label.style.color = '#d8b4fe'; // Roxo claro
            }

            label.innerHTML = `<input type="checkbox" value="${id}" checked> ${name} ${isFixed ? 'üîí' : ''}`;
            label.querySelector('input').onchange = updateShapesList;
            
            const delBtn = document.createElement('button');
            delBtn.className = 'btn-delete-shape';
            delBtn.innerHTML = 'üóëÔ∏è';
            delBtn.title = 'Excluir Forma';
            delBtn.onclick = (e) => {
                e.preventDefault(); e.stopPropagation();
                delete customShapesRegistry[id];
                container.remove();
                updateShapesList();
            };
            
            container.appendChild(label);
            container.appendChild(delBtn);
            document.getElementById('shapesContainer').appendChild(container);
            updateShapesList();
            toggleCreator(false);
        };

        document.getElementById('btnOpenCreator').onclick = () => toggleCreator(true);

        init();
    </script>
</body>
</html>


